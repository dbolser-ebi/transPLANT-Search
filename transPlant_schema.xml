<?xml version="1.0" encoding="UTF-8" ?>

<schema name="transplant" version="1.5">
  
  <!-- Now we define the fields themselves... -->
  
  <!-- Fields are based on the transPLANT integrated search schema
       v0.1 document -->
  
  <!-- NOTE: I haven't used docValues (available in Solr since 4.2)
       for the fields that we'll be faceting on, althought this could
       provide a performace advantage in the most recent versions of
       Solr. -->
  
  <!-- NOTE: All fields are copied into the main description
       (text_general) field (below) so that free text searches for
       their values will return meaningfull results, regardless of
       their use as facets. -->
  
  <!-- TODO: What do we need to store? i.e. if a field is being used
       only for faceting, do we need to store it's values or just
       simply index them? For now I'm going to just index and see
       where that gets us...
       
       Seems this rule applies just for facet fields, other fields
       should be stored if you want the value back, even if they are
       being indexed...
       
       So:
         * used for faceting = true/false,
         * copied to description = false/true
       
       -->
  
  <fields>
    
    <!-- Although the entry_type is specified in the schema document
         as an enum, there is no technical need to implement it as
         such in Solr. -->
    <field name="entry_type"    type="string" indexed="true"  stored="false" required="true"  />
    
    <!-- Together these three fields define the unique identifier for
         a given entry, being hashed together using Lookup3Signature
         into the 'id' field. See the 'dedupe' update request
         processor in solrconfig.xml. -->
    <field name="database_name" type="string" indexed="true"  stored="false" required="true"  />
    <field name="db_id"         type="string" indexed="false" stored="true"  required="true"  />
    <field name="db_version"    type="int"    indexed="false" stored="true"  required="false" />
    
    <field name="id"            type="string" indexed="true"  stored="false" required="true"  />
    
    <!-- This is the most important field from the free text search
         point of view. The field is stored for retreival and
         highlighting, and is defined as multiValued because several
         other fields are copied here to allow both faceting and free
         text search. We could add termVectors and termPositions for
         highlighting! -->
    <field name="description"   type="text_general" multiValued="true"
                                              indexed="true"  stored="true"  required="true"  />
    
    <field name="url"           type="string" indexed="false" stored="true"  required="true"  />
    
    <field name="species"       type="int"    indexed="true"  stored="false" required="false" />
    <field name="sample"        type="string" indexed="true"  stored="false" required="false" />
    
    
    
    <!-- Now we define the fields that are used by the other data
         types that we want to index... -->
    
    <!-- Sequence feature -->
    
    <!-- The conceptual schema has all fields associated with a
         sequence feature as mandatory (if the document represents a
         sequence feature). However, not all documents are sequence
         features, so I can't make this field 'required' by
         solr... The requirement will have to be enforced client side
         I guess? -->
    
    <!-- Another hierarchical facet field to think about... -->
    <field name="feature_type"     type="string" indexed="true"  stored="false" required="false" />
    <field name="sequence_id"      type="string" indexed="false" stored="true"  required="false" />
    <field name="sequence_version" type="int"    indexed="false" stored="true"  required="false" />
    <field name="start_position"   type="tint"   indexed="true"  stored="true"  required="false" />
    <field name="end_position"     type="tint"   indexed="true"  stored="true"  required="false" />
    
    
    
    <!-- Genetic marker -->
    
    <field name="map"              type="string" indexed="true"  stored="false"  required="false" />
    <field name="map_position"     type="tfloat" indexed="true"  stored="false"  required="false" />
    
    <!-- Links back to another db_id -->
    <field name="db_id_xref"       type="string" indexed="true"  stored="true"   required="false" />
    
    
    
    <!-- Accession -->
    
    <field name="authority"        type="string" indexed="true"  stored="false"  required="false" />
    
    
    
    <!-- Phenotype -->
    
    <field name="trait"            type="string" indexed="false"  stored="true"  required="false" multiValued="true" />
    <field name="trait_id"         type="string" indexed="true"   stored="false" required="false" multiValued="true" />
    <field name="environment"      type="string" indexed="false"  stored="true"  required="false" multiValued="true" />
    <field name="environment_id"   type="string" indexed="true"   stored="false" required="false" multiValued="true" />
    <field name="statistic"        type="string" indexed="false"  stored="true"  required="false" />
    <field name="unit"             type="string" indexed="false"  stored="true"  required="false" />
    
    
    
    <!-- QTL or GWAS result -->
    <field name="genotype"         type="string" indexed="true"   stored="false" required="false" />
    <field name="transformation"   type="string" indexed="true"   stored="false" required="false" />
    <field name="method"           type="string" indexed="true"   stored="false" required="false" />
    
    
    
    <!-- Links back to another db_id -->
    <!-- <field name="db_id_xref"       type="string" indexed="true"  stored="true"   required="false" /> -->
    
    
    
  </fields>
  
  <!-- Field to use to determine and enforce document
       uniqueness. Unless this field is marked with required="false",
       it will be a required field. -->
  <uniqueKey>id</uniqueKey>
  
  <!-- Copy (almost) everything into the description field for free
       text searches -->
  <copyField source="entry_type"    dest="description"/>
  <copyField source="database_name" dest="description"/>
  <copyField source="db_id"         dest="description"/>
  <!-- <copyField source="db_version"       dest="description"/> -->
  <copyField source="species"       dest="description"/>
  <copyField source="sample"        dest="description"/>
  
  <copyField source="feature_type"  dest="description"/>
  <copyField source="sequence_id"   dest="description"/>
  <!-- <copyField source="sequence_version" dest="description"/> -->
  <!-- <copyField source="start_position"   dest="description"/> -->
  <!-- <copyField source="end_position"     dest="description"/> -->
  
  <copyField source="map"           dest="description"/>
  <!-- <copyField source="map_position"     dest="description"/> -->
  
  <copyField source="authority"     dest="description"/>
  
  <copyField source="feature_type"  dest="description"/>
  <copyField source="feature_type"  dest="description"/>
  <copyField source="feature_type"  dest="description"/>
  





  <!-- Lets start with field types... -->
  
  <types>
    <!-- The StrField type is not analyzed, but indexed/stored verbatim.
         It supports docValues but in that case the field needs to be
         single-valued and either required or have a default value. -->
    <fieldType name="string" class="solr.StrField" sortMissingLast="true"/>
    
    <!-- Default numeric field types. For faster range queries, consider
         the tint/tfloat/tlong/tdouble types. -->
    <fieldType name=   "int" class="solr.TrieIntField"   precisionStep="0" positionIncrementGap="0"/>
    <fieldType name= "float" class="solr.TrieFloatField" precisionStep="0" positionIncrementGap="0"/>
    
    <!-- Numeric field types that index each value at various levels of
         precision to accelerate range queries when the number of values
         between the range endpoints is large.
         
         Smaller precisionStep values (specified in bits) will lead to
         more tokens indexed per value, slightly larger index size, and
         faster range queries. A precisionStep of 0 disables indexing at
         different precision levels. -->
    <fieldType name=  "tint" class="solr.TrieIntField"   precisionStep="8" positionIncrementGap="0"/>
    <fieldType name="tfloat" class="solr.TrieFloatField" precisionStep="8" positionIncrementGap="0"/>
    
    <!-- The format for this date field is of the form
         '1995-12-31T23:59:59Z'. For faster range queries, consider the
         tdate type. -->
    <fieldType name=  "date" class="solr.TrieDateField"  precisionStep="0"/>
    
    <!-- A Trie based date field for faster date range queries and date
         faceting. -->
    <fieldType name= "tdate" class="solr.TrieDateField"  precisionStep="6" positionIncrementGap="0"/>
    
    
    
    <!-- Fields for text I'm not convinced that we need anything
         particularly fancy here ... -->
    
    <!-- A text field that only splits on whitespace for exact matching
         of words -->
    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
      <analyzer>
        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
      </analyzer>
    </fieldType>
    
    
    <!-- A general text field that has reasonable, generic
         cross-language defaults: it tokenizes with StandardTokenizer,
         removes stop words from case-insensitive "stopwords.txt", and
         down cases. Synonyms are applied at query time. -->
    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
      <analyzer type="index">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
      <analyzer type="query">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
        <filter class="solr.SynonymFilterFactory" ignoreCase="true" synonyms="synonyms.txt" expand="true"/>
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
    </fieldType>
    
    
    <!-- A text field with defaults appropriate for English: it
         tokenizes with StandardTokenizer, removes English stop words
         (lang/stopwords_en.txt), down cases, protects words from
         protwords.txt, and finally applies Porter's stemming. Synonyms
         are applied at query time. -->
    <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
      <analyzer type="index">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.EnglishPossessiveFilterFactory"/>
        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
        <filter class="solr.PorterStemFilterFactory"/>
      </analyzer>
      <analyzer type="query">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.EnglishPossessiveFilterFactory"/>
        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
        <filter class="solr.PorterStemFilterFactory"/>
      </analyzer>
    </fieldType>
    
  </types>
  
  
  
  


</schema>
